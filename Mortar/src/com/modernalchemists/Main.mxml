<?xml version="1.0" encoding="utf-8"?>
<mx:WindowedApplication xmlns:mx="http://www.adobe.com/2006/mxml"
creationComplete="creationCompleteHandler();"
   backgroundColor="white"  width="1024" height="890" paddingTop="0" paddingLeft="0" paddingRight="0" paddingBottom="0"
>
    <mx:Script>
        <![CDATA[
		import mx.events.FlexEvent;

		public static const OS_TYPE:String = flash.system.Capabilities.os.substr(0, 3);
		public static const OS_WIN:String = "Win";
		public static const OS_MAC:String = "Mac";
		
		private function creationCompleteHandler():void
		{
			switch( OS_TYPE )
			{
				case OS_WIN:
				log("OS: Windows");
				break;
                
                case OS_MAC:
                log("OS: Mac");
                break;
			}
			
            loadProjectList();
		} 

        import flash.desktop.NativeProcess;
        import flash.desktop.NativeProcessStartupInfo;
        import flash.errors.IOError;
        import flash.events.Event;
        import flash.events.NativeProcessExitEvent;
        import flash.events.ProgressEvent;
        import flash.filesystem.File;
        import mx.collections.ArrayCollection;
        import mx.controls.Alert;
        import mx.managers.PopUpManager;
        import mx.managers.PopUpManager;
        import mx.core.IFlexDisplayObject;
        import com.modernalchemists.AddProject;

		private const PATCH_SUCCESSFUL:int = 1;
		private const PATCH_AFTER_NOT_FOUND:int = -2;
		private const HEADER_STRING:String = "/*\tThis file has been patched by the allmighty Zog! \n\t(c)Modern Alchemists: www.modern-alchemists.com\n\tThis is free software, so in return, please buy our games! =)\n*/\n\n";
		
        //Mortar Paths:
        private var MORTAR_BIN:String 		    = File.applicationDirectory.nativePath;
        private var MORTAR_PROJECTS:String 		= File.applicationDirectory.nativePath + "/projects/";
        private var MORTAR_PATCHES:String 		= File.applicationDirectory.nativePath + "/patches/";
        
        
		private var S3DX_PATH:String 		= File.applicationDirectory.nativePath + "/files/s3dx/";
		
        //obsolete:
        private var ADMOB_JAR:String 		= File.applicationDirectory.nativePath  + "/files/maad/admob-sdk-android.jar";
        
        //obsolete:
        private var ADMOB_WRAPPER:String 	= File.applicationDirectory.nativePath  + "/files/maad/AdMobWrapper.java";
        
        //obsolete:
        private var MAAD_C:String       	= File.applicationDirectory.nativePath  + "/files/maad/maad.c";
        
        //TODO: check these vars:
		private var PROJ_PATH:String 		= "Path to Eclipse project";
		private var BUNDLE_ID:String 		= "Your bundle id, such as com.modernalchemists.aaargpimples";
		private var PROJ_NAME:String 		= "The project name (STK name)";
        private var PROJ_SRC:String 		= "Path to Eclipse project/src";
        private var PROJ_GAME_FILE:String	= "YourGame.java file";
        private var PROJ_GAME_PATH:String 	= "Path where YourGame.java file is in.";
        private var PATCH_THIS:String       = "Path where PAT file is executed from.";

        //TODO: prePatch triggered per script?

		
		private var succeeded:Boolean = true;
		private var process:NativeProcess = new NativeProcess();
		[Bindable] private var consoleOutput:ArrayCollection = new ArrayCollection();
		[Bindable] private var LABEL_WIDTH:int = 90;
	
        //List of *.pro files found:
        [Bindable] private var projectList:Array = new Array();
        
        //List of available patches:
        [Bindable] private var patchList:Array = new Array();
        
        //The selected patches for the current build:
        [Bindable] private var patchBuildList:Array= new Array();
        
        
		private function prePatch():void
		{
			//Copy stuff:
			//NOTE: copy dir deletes all the files in the new dir. That's why I copy each file manually... :/
		
			//S3DX files:
			try
			{
				copyFile( S3DX_PATH + "/S3DXAIConstant.h", 	PROJ_PATH + "/jni/S3DXAIConstant.h" );
				copyFile( S3DX_PATH + "/S3DXAIEngineAPI.h", PROJ_PATH + "/jni/S3DXAIEngineAPI.h" );
				copyFile( S3DX_PATH + "/S3DXAIFunction.h", 	PROJ_PATH + "/jni/S3DXAIFunction.h" );
				copyFile( S3DX_PATH + "/S3DXAIModel.h", 	PROJ_PATH + "/jni/S3DXAIModel.h" );
				copyFile( S3DX_PATH + "/S3DXAIPackage.h", 	PROJ_PATH + "/jni/S3DXAIPackage.h" );
				copyFile( S3DX_PATH + "/S3DXAIVariable.h", 	PROJ_PATH + "/jni/S3DXAIVariable.h" );
				copyFile( S3DX_PATH + "/S3DXAIVariables.h", PROJ_PATH + "/jni/S3DXAIVariables.h" );
				copyFile( S3DX_PATH + "/S3DXConfig.h", 		PROJ_PATH + "/jni/S3DXConfig.h" );
				copyFile( S3DX_PATH + "/S3DXMacros.h", 		PROJ_PATH + "/jni/S3DXMacros.h" );
				copyFile( S3DX_PATH + "/S3DXPlatform.h", 	PROJ_PATH + "/jni/S3DXPlatform.h" );
				copyFile( S3DX_PATH + "/S3DXPlugin.h", 		PROJ_PATH + "/jni/S3DXPlugin.h" );
				copyFile( S3DX_PATH + "/S3DXTypes.h", 		PROJ_PATH + "/jni/S3DXTypes.h" );
				
				//Custom __PROJ_NAME__.java:
				var jGame:String = PROJ_PATH + "/src";
				
				var bundleBits:Array = BUNDLE_ID.split(".");
				var bundlePath:String = "";
				for (var i:int = 0; i < bundleBits.length; i++)
				{
					jGame += "/" +  bundleBits[i];
					bundlePath +=  bundleBits[i] + "/"
				}

					
				//AndroidManifest.xml
				replaceInFile( PROJ_PATH + "/AndroidManifest.xml",
					"android:launchMode=\"singleInstance\"",
					"android:launchMode=\"standard\"" );
					
					
				var patchFilePath:String = File.applicationDirectory.nativePath + "/patches/";
				//__PROJ__/jni/S3DClient.cpp
				var success:int = patchFileAfter( PROJ_PATH + "/jni/S3DClient.cpp", 
					loadFileToString( patchFilePath + "common/cpp_client_header_a.txt" ),
					loadFileToString( patchFilePath + "common/cpp_client_header_i.txt" )
				);			
		
						
			}
			catch ( err:IOError )
			{
				succeeded = false;
				Alert.show(err.message + "\nMaybe Path to S3DX is incorrect?");
			}			
			
		}
		
		private function postPatch():void
		{
			if ( succeeded )
			{
				//Alert.show("Pachting succeeded.\nPost-Build options currently not available.", "Succeeded");
                Alert.show("Pachting succeeded!", "Succeeded");
				/*
				if(NativeProcess.isSupported)
				{
					if ( bAntBuild.selected )
					{
						startAntBuild();
					}
				}*/			
			}
			else
			{
				Alert.show("Something went wrong! Please dial 1-800-MORTAR-ME", "Epic fail!");
			}
		}
		
		private function patchAdMob():void
		{
            //__PROJ__/__BUNDLE_ID__/__PROJ_NAME__.java:
            var jGame:String = PROJ_PATH + "/src";
            
            var bundleBits:Array = BUNDLE_ID.split(".");
            var bundlePath:String = "";
            for (var i:int = 0; i < bundleBits.length; i++)
            {
                jGame += "/" +  bundleBits[i];
                bundlePath +=  bundleBits[i] + "/"
            }
            
            jGame += "/" +  PROJ_NAME + ".java";
            log("Game java file is:" + jGame);

            
			try
			{
                log("Copy file " + ADMOB_JAR + " to " + PROJ_PATH + "/libs/admob.jar" );
				copyFile( ADMOB_JAR, PROJ_PATH + "/libs/admob.jar" );
                
                log("Copy file " + ADMOB_WRAPPER + " to " + PROJ_PATH + "/src/com/modernalchemists/maad/android/AdMobWrapper.java" );
                copyFile( ADMOB_WRAPPER, PROJ_PATH + "/src/com/modernalchemists/maad/android/AdMobWrapper.java" );
                
                log("Copy file " + MAAD_C + " to " + PROJ_PATH + "/jni/maad.c");
                copyFile( MAAD_C, PROJ_PATH + "/jni/maad.c" );
			}
			catch ( err:IOError )
			{
				succeeded = false;
				Alert.show(err.message + "\nError copying files.");
			}
			
			//Patching Eclispe files:
			var patchFilePath:String = File.applicationDirectory.nativePath + "/patches/admob/";
            
			try
			{
                log("Patching Admob related file: .classpath");
                var success:int = patchFileBefore( PROJ_PATH + "/.classpath", 
					"</classpath>",
					"<classpathentry kind=\"lib\" exported=\"true\" path=\"libs/admob.jar\"/>\n"
				);
                
                
                log("Patching Admob related file:" + jGame);
				success = patchFileAfter( jGame, 
					loadFileToString( patchFilePath + "java_import_a.txt" ),
					loadFileToString( patchFilePath + "java_import_i.txt" )
				);
                


				success = patchFileAfter( jGame, 
					loadFileToString( patchFilePath + "java_view_a.txt" ),
					loadFileToString( patchFilePath + "java_view_i.txt" )
				);
                
				
				success = patchFileBefore( jGame, 
					loadFileToString( patchFilePath + "java_visible_b.txt" ),
					loadFileToString( patchFilePath + "java_visible_i.txt" )
				);
				
				success = patchFileAfter( jGame, 
					loadFileToString( patchFilePath + "java_addToView_a.txt" ),
					loadFileToString( patchFilePath + "java_addToView_i.txt" )
				);
						

				
				
				//AndroidManifest.xml
                log("Patching Admob related file:AndroidManifest.xml");
				success = patchFileAfter( PROJ_PATH + "/AndroidManifest.xml", 
					loadFileToString( patchFilePath + "amanifest_inet_a.txt" ),
					loadFileToString( patchFilePath + "amanifest_inet_i.txt" )
				);

				success = patchFileBefore( PROJ_PATH + "/AndroidManifest.xml", 
					loadFileToString( patchFilePath + "amanifest_puid_b.txt" ),
					loadFileToString( patchFilePath + "amanifest_puid_i.txt" )
				);

				
                log("Patching Admob related file:S3DClient.cpp");
				success = patchFileAfter( PROJ_PATH + "/jni/S3DClient.cpp", 
					loadFileToString( patchFilePath + "cpp_client_include_a.txt" ),
					loadFileToString( patchFilePath + "cpp_client_include_i.txt" )
				);
                
				success = patchFileAfter( PROJ_PATH + "/jni/S3DClient.cpp", 
					loadFileToString( patchFilePath + "cpp_client_load_a.txt" ),
					loadFileToString( patchFilePath + "cpp_client_load_i.txt" )
				);
				
                
                if ( success != PATCH_SUCCESSFUL )
                {
                    succeeded = false;
                }
				
			}
			catch ( err:IOError )
			{
				succeeded = false;
				Alert.show(err.message + "\nError patching files. Check project path, bundle id and project name!");
			}
			
			
			/*
			if ( succeeded )
			{
				//Alert.show("Success.");

				if(NativeProcess.isSupported)
				{
					if ( bAntBuild.selected )
					{
						startAntBuild();
					}
				}			
			}*/
		}
		
		
        /*
		private function startAntBuild():void
		{
			//"%ANT_HOME%/bin/ant" -buildfile "%1"
			
			var file:File = File.desktopDirectory.resolvePath(PROJ_PATH + "/.project");
			file = file.resolvePath(File.applicationDirectory.nativePath + "/settings/antbuild.cmd");
			
			var nativeProcessStartupInfo:NativeProcessStartupInfo = new NativeProcessStartupInfo();
			nativeProcessStartupInfo.executable = file;
			
			var args:Vector.<String> = new Vector.<String>();
			var buildFile:String = PROJ_PATH + "/build.xml";
			//var antExe:String = "\"" + ANT_HOME + "/bin/ant\"";
			//var buildFile:String = "-buildfile \"" + PROJ_PATH + "/build.xml\"";
			//antExe += " " + buildFile;
			//args.push(antExe);
			args.push(buildFile);
			nativeProcessStartupInfo.arguments = args;
			
			process = new NativeProcess();
			process.addEventListener(NativeProcessExitEvent.EXIT, onBuildProcessExit);
			process.addEventListener(ProgressEvent.STANDARD_OUTPUT_DATA, onOutput);
			
			process.start(nativeProcessStartupInfo);
			//trace("build");
		
		}
        */
		
        /*
		private function onBuildProcessExit(e:Event):void 
		{
			//trace("done bnuild");
			if ( bSignAPK.selected )
			{
				startSignAPK();
			}
		}
        */
		
        /*
		private function startSignAPK():void
		{
			var file:File = File.desktopDirectory.resolvePath(PROJ_PATH + "/.project");
			file = file.resolvePath(File.applicationDirectory.nativePath + "/settings/adbsign.cmd");
			
			var nativeProcessStartupInfo:NativeProcessStartupInfo = new NativeProcessStartupInfo();
			nativeProcessStartupInfo.executable = file;
			
			var args:Vector.<String> = new Vector.<String>();
			var buildFile:String = PROJ_PATH + "/bin/" + PROJ_NAME + "-unsigned.apk";
			args.push(buildFile);
			args.push(KEYSTORE);
			args.push(KEYPASS);
			args.push(ALIAS);
			nativeProcessStartupInfo.arguments = args;
			
			process.removeEventListener(NativeProcessExitEvent.EXIT, onBuildProcessExit);

			process = new NativeProcess();
			process.addEventListener(NativeProcessExitEvent.EXIT, onSignAPKProcessExit);
			process.addEventListener(ProgressEvent.STANDARD_OUTPUT_DATA, onOutput);
			
			process.start(nativeProcessStartupInfo);			
		}
        */
		
        /*
		private function onSignAPKProcessExit(e:Event):void 
		{
			if ( bInsallOnDevice.selected )
			{
				startInstallOnDevice();
			}
		}
        */
		
        /*
		private function startInstallOnDevice():void
		{
			var file:File = File.desktopDirectory.resolvePath(PROJ_PATH + "/.project");
			file = file.resolvePath(File.applicationDirectory.nativePath + "/settings/adbinstall.cmd");
			
			var nativeProcessStartupInfo:NativeProcessStartupInfo = new NativeProcessStartupInfo();
			nativeProcessStartupInfo.executable = file;
			
			var args:Vector.<String> = new Vector.<String>();
			var buildFile:String = PROJ_PATH + "/bin/" + PROJ_NAME + "-unsigned.apk";
			args.push(buildFile);
			nativeProcessStartupInfo.arguments = args;
			
			process.removeEventListener(NativeProcessExitEvent.EXIT, onSignAPKProcessExit);
			
			process = new NativeProcess();
			process.addEventListener(NativeProcessExitEvent.EXIT, onInstallOnDeviceProcessExit);
			process.addEventListener(ProgressEvent.STANDARD_OUTPUT_DATA, onOutput);
			
			process.start(nativeProcessStartupInfo);			
		}
        */
		
        /*
		private function onInstallOnDeviceProcessExit(e:Event):void 
		{
			//trace("done signing APK");
		}
        */
        
        private function log(message:String):void
        {
            consoleOutput.addItem(message);
        }
				
		private function onOutput(event:ProgressEvent):void
		{
			consoleOutput.addAll(new ArrayCollection(process.standardOutput.readUTFBytes(process.standardOutput.bytesAvailable).split('\n')));
		}
		
		private function copyDirectory( dirToCopy:String, newLocation:String ):void 
		{
			var originalLoc:File = File.desktopDirectory.resolvePath( dirToCopy );
			var copyLoc:File = File.desktopDirectory.resolvePath( newLocation );
			originalLoc.copyTo( copyLoc, true ); //bool = overwrite
		}
		
		private function copyFile( fileToCopy:String, newLocation:String ):void
		{
			var originalLoc:File = File.desktopDirectory.resolvePath( fileToCopy );
			var copyLoc:File = File.desktopDirectory.resolvePath( newLocation );
			originalLoc.copyTo( copyLoc, true );
		}
		
              
		
		private function getFilesRecursive(folder:String, outFileList:Array):void
		{
			//var fileList:Array = new Array();
            //the current folder object
            var currentFolder:File = File.desktopDirectory.resolvePath( folder );
            
            //the current folder's file listing
            var files:Array = currentFolder.getDirectoryListing();
            
            //iterate and put files in the result and process the sub folders recursively
            for (var f:int = 0; f < files.length; f++) {
                if ( (files[f] as File).isDirectory) {
                    if ((files[f] as File).name !="." && (files[f] as File).name !="..") {
                        //it's a directory
                        getFilesRecursive((files[f] as File).nativePath, outFileList);
                    }
                } else {
                    //it's a file yupeee
                    outFileList.push((files[f] as File).nativePath);
                }
            }            
            
			//return fileList;
        }

		private function getFilesRecursiveExt(folder:String, extension:String, outFileList:Array):void
		{
            var currentFolder:File = File.desktopDirectory.resolvePath( folder );
            
            //the current folder's file listing
            var files:Array = currentFolder.getDirectoryListing();
            
            //iterate and put files in the result and process the sub folders recursively
            for (var f:int = 0; f < files.length; f++) {
                if ( (files[f] as File).isDirectory) {
                    if ((files[f] as File).name !="." && (files[f] as File).name !="..") {
                        //it's a directory
                        getFilesRecursiveExt((files[f] as File).nativePath, extension, outFileList);
                    }
                } else {
                    //it's a file yupeee
                    if ((files[f] as File).extension == extension )
                    {
                        outFileList.push((files[f] as File).nativePath);
                    }
                }
            }            
            
			//return fileList;
        }
        
        	
		
		
		/**
		 * 
		 * @param	filename
		 * @param	after
		 * @param	insert
		 * @return
		 */
		private function patchFileAfter( filename:String, after:String, insert:String ):int 
		{
			//1) Load file content to string:
			var str:String = loadFileToString( filename );
			//trace( str );

			//trace ("####################\n" + after + "\n##################\n" );
			
			//2) Find the location to insert patch string:
			var pos:int = str.indexOf( after );
			//trace( "pos:" + pos );
			
			if ( pos == -1 )
			{
				return PATCH_AFTER_NOT_FOUND;
			}
			
			//2.5) Insert header info:
			var hPos:int = str.indexOf( HEADER_STRING );
			if ( hPos == -1 )
			{
				//str = HEADER_STRING + str;
			}
	
			
			//3) Insert the patch string:
			var parts:Array = str.split( after );
			
			if ( parts.length != 2 )
			{
				throw new Error( "Couldn't split string, or split it into more than one piece." );
			}
			
			var newString:String = "";
		
			newString = parts[0] + after + insert + parts[1];
			
			//trace( "\n\n" + newString);
			
			//4) Save the new file to old location:
			var file:File = File.desktopDirectory.resolvePath(filename);
			var fileStream:FileStream = new FileStream();
			fileStream.open(file, FileMode.WRITE);
			fileStream.writeUTFBytes(newString);
			fileStream.close();
			
			return PATCH_SUCCESSFUL;
		}
		
	private function patchFileBefore( filename:String, before:String, insert:String ):int 
		{
			//1) Load file content to string:
			var str:String = loadFileToString( filename );
			//trace( str );

			//trace ("####################\n" + before + "\n##################\n" );
			
			//2) Find the location to insert patch string:
			var pos:int = str.indexOf( before );
			//trace( "pos:" + pos );
			
			if ( pos == -1 )
			{
				return PATCH_AFTER_NOT_FOUND;
			}
			
			//2.5) Insert header info:
			var hPos:int = str.indexOf( HEADER_STRING );
			if ( hPos == -1 )
			{
				//str = HEADER_STRING + str;
			}

			
			//3) Insert the patch string:
			var parts:Array = str.split( before );
			
			if ( parts.length != 2 )
			{
				throw new Error( "Couldn't split string, or split it into more than one piece." );
			}
			
			var newString:String = "";
			newString = parts[0] + insert + before + parts[1];
			
			//trace( "\n\n" + newString);
			
			//4) Save the new file to old location:
			var file:File = File.desktopDirectory.resolvePath(filename);
			var fileStream:FileStream = new FileStream();
			fileStream.open(file, FileMode.WRITE);
			fileStream.writeUTFBytes(newString);
			fileStream.close();
			
			return PATCH_SUCCESSFUL;
		}
			
		private function replaceInFile(filename:String, findStr:String, replaceStr:String):void
		{
			var projFileStr:String = loadFileToString( filename )
			projFileStr = replace( projFileStr, findStr, replaceStr); 

			var file:File = File.desktopDirectory.resolvePath(filename);
			var fileStream:FileStream = new FileStream();
			fileStream.open(file, FileMode.WRITE);
			fileStream.writeUTFBytes(projFileStr);
			fileStream.close();			
		}
		
		private function loadFileToString( filename:String ):String 
		{
			var file:File = File.applicationDirectory.resolvePath(filename);
			//var file:File = File.desktopDirectory.resolvePath(filename);
			var fileStream:FileStream = new FileStream();
			fileStream.open(file, FileMode.READ);
			//var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
			var str:String = fileStream.readUTFBytes(file.size);
			//trace( str );
			fileStream.close();

			return str;
		}
		
		private function replace(input:String, replace:String, replaceWith:String):String
		{
			//change to StringBuilder
			var sb:String = new String();
			var found:Boolean = false;
		 
			var sLen:Number = input.length;
			var rLen:Number = replace.length;
		 
			for (var i:Number = 0; i < sLen; i++)
			{
				if(input.charAt(i) == replace.charAt(0))
				{
					found = true;
					for(var j:Number = 0; j < rLen; j++)
					{
						if(!(input.charAt(i + j) == replace.charAt(j)))
						{
							found = false;
							break;
						}
					}
		 
					if(found)
					{
						sb += replaceWith;
						i = i + (rLen - 1);
						continue;
					}
				}
				sb += input.charAt(i);
			}
			//TODO : if the string is not found, should we return the original
			//string?
			return sb;
		}

		]]>
	</mx:Script>
	
	<mx:Script>
		<![CDATA[
		import flash.events.Event;
		import flash.filesystem.File;
		private var directory:File = File.documentsDirectory;

		private function onBrowseProjectPath():void
		{
			directory.addEventListener(Event.SELECT, selectedProjectPath);
			directory.browseForDirectory("Path to Android/Eclipse-Project.");
		}

		private function selectedProjectPath(e:Event):void {
			PROJ_PATH = proj.text = directory.nativePath;
			directory.removeEventListener(Event.SELECT, selectedProjectPath);
		}		

		
		/*
		private function onPostPatchOperationChangedAnt():void
		{
			if ( bAntBuild.selected )
			{
				//bSignAPK.selected = false;
				//bInsallOnDevice.selected = false;
			}	

			else 
			{
				bSignAPK.selected = false;
				bInsallOnDevice.selected = false;
			}	
		}
        */

        /*
		private function onPostPatchOperationChangedSignAPK():void
		{
			if ( bSignAPK.selected )
			{
				bAntBuild.selected = true;
			}

			else 
			{
				bInsallOnDevice.selected = false;
			}

			//bAntBuild
			//bSignAPK
			//bInsallOnDevice
		}
        */
		
        /*
		private function onPostPatchOperationChangedInstall():void
		{
			if ( bInsallOnDevice.selected )
			{
				bSignAPK.selected = true;
				bAntBuild.selected = true;
			}
		}
        */
	
		private function onSaveSettings():void
		{
			log("Saving settings for project: " + (projectListCombo.selectedItem)as String);
			
			var settings:String = "";
			var split:String = "::|::";

			settings += "PROJ_PATH" + split + PROJ_PATH + "\n";
			settings += "BUNDLE_ID" + split + BUNDLE_ID + "\n";
			settings += "PROJ_NAME" + split + PROJ_NAME + "\n";
            
            for each(var patch:String in patchBuildList)
            {
                settings += "PATCH" + split + patch + "\n";
            }
			
			var settingsFileString:String = MORTAR_PROJECTS + (projectListCombo.selectedItem)as String;
			var file:File = File.desktopDirectory.resolvePath(settingsFileString);
			var fileStream:FileStream = new FileStream();
			fileStream.open(file, FileMode.WRITE);
			fileStream.writeUTFBytes(settings);
			fileStream.close();
		}
		
        private function loadPatchFile(filename:String):void
        {
            log("Loading patch file:" + filename);
            
			var fileString:String = loadFileToString(filename);
			
            //Update variables before parsing script:
            var file:File = File.applicationDirectory.resolvePath(filename);
            PATCH_THIS = file.nativePath.substr(0, file.nativePath.length - file.name.length-1);
            
            PROJ_SRC = PROJ_PATH.concat("\\src");
            
            PROJ_GAME_PATH = PROJ_PATH + "\\src";
            
            var bundleBits:Array = BUNDLE_ID.split(".");
            var bundlePath:String = "";
            for (var i:int = 0; i < bundleBits.length; i++)
            {
                PROJ_GAME_PATH += "\\" +  bundleBits[i];
                bundlePath +=  bundleBits[i] + "\\"
            }
            
            PROJ_GAME_FILE = PROJ_GAME_PATH + "\\" + PROJ_NAME + ".java";

            //log("PATCH_THIS:" + PATCH_THIS);
            //log("PROJ_PATH:" + PROJ_PATH);
            //log("PROJ_SRC:" + PROJ_SRC);
            //log("PROJ_GAME_PATH:" + PROJ_GAME_PATH);
            //log("PROJ_GAME_FILE:" + PROJ_GAME_FILE);
            
            
			var commands:Array = fileString.split("\n");
			
			for each(var command:String in commands) 
			{
                var cmd:String = command.substr(3, command.length);
                var args:Array = new Array();
                var success:int = 0;
                switch( command.substr(0, 3) )
                {
                    case "LOG":
                        log(cmd);
                    break;
                    
                    case "COF":
                        args = parseScriptingArguments( parseScriptingVariables(cmd) );
                        if (args.length != 2)
                        {
                            log("ERROR: RIF argument count must be 2 (is " +  args.length + "): " + cmd);
                            continue;
                        }
                        log("Copy file: " + "from:\"" + args[0] + "\" to:\"" + args[1] + "\"");
                        copyFile( args[0], args[1] );
                    break;
                    
                    case "RIF":
                        args = parseScriptingArguments( parseScriptingVariables(cmd) );
                        if (args.length != 3)
                        {
                            log("ERROR: RIF argument count must be 3 (is " +  args.length + "): " + cmd);
                            continue;
                        }
                        log("Replace in file: \"" + args[0] + "\" find:\"" + args[1] + "\" replace:\"" + args[2] + "\"");
                        replaceInFile( args[0], args[1], args[2] );
                    break;

                    case "IFA":
                        args = parseScriptingArguments( parseScriptingVariables(cmd) );
                        if (args.length != 3)
                        {
                            log("ERROR: IFA argument count must be 3 (is " +  args.length + "): " + cmd);
                            continue;
                        }
                        log("Insert in file after. File: \"" + args[0] + "\" after:\"" + args[1] + "\" insert:\"" + args[2] + "\"");
                        success = patchFileAfter( args[0], loadFileToString( args[1] ), loadFileToString( args[2] ) );
                    break;

                    case "IFB":
                        args = parseScriptingArguments( parseScriptingVariables(cmd) );
                        if (args.length != 3)
                        {
                            log("ERROR: IFB argument count must be 3 (is " +  args.length + "): " + cmd);
                            continue;
                        }
                        log("Insert in file before. File: \"" + args[0] + "\" before:\"" + args[1] + "\" insert:\"" + args[2] + "\"");
                        success = patchFileBefore( args[0], loadFileToString( args[1] ), loadFileToString( args[2] ) );
                    break;

                    case "ISA":
                        args = parseScriptingArguments( parseScriptingVariables(cmd) );
                        if (args.length != 3)
                        {
                            log("ERROR: ISA argument count must be 3 (is " +  args.length + "): " + cmd);
                            continue;
                        }
                        log("Insert in string after. File: \"" + args[0] + "\" after:\"" + args[1] + "\" insert:\"" + args[2] + "\"");
                        success = patchFileAfter( args[0], args[1], args[2] );
                    break;

                    case "ISB":
                        args = parseScriptingArguments( parseScriptingVariables(cmd) );
                        if (args.length != 3)
                        {
                            log("ERROR: ISB argument count must be 3 (is " +  args.length + "): " + cmd);
                            continue;
                        }
                        log("Insert in string before. File: \"" + args[0] + "\" before:\"" + args[1] + "\" insert:\"" + args[2] + "\"");
                        success = patchFileBefore( args[0], args[1], args[2] );
                    break;
                }
            }   
        }
        
        private function trimWhitespace($string:String):String 
        {
            if ($string == null) {
                return "";
            }
            return $string.replace(/^\s+|\s+$/g, "");
        }
        
        private function parseScriptingArguments(command:String):Array
        {
            var arr:Array = command.split("§§§");
            
            for (var i:int = 0; i < arr.length; i++ )
            {
                arr[i] =  trimWhitespace(arr[i]);
            }
                        
            //if (arr.length != 2)
            //{
            //    log("ERROR: parseScriptingArguments with command: " + command);
            //    log("... array count is " + arr.length);
            //}
            
            return arr;
        }
        
        private function parseScriptingVariables(command:String):String
        {
            command = command.split("%PROJ%").join(PROJ_PATH);
            command = command.split("%SRC%").join(PROJ_SRC);
            command = command.split("%GAME%").join(PROJ_GAME_FILE);
            command = command.split("%GAMEDIR%").join(PROJ_GAME_PATH);
            command = command.split("%THIS%").join(PATCH_THIS);
            
            command = command.split("%MORTAR_BIN%").join(MORTAR_BIN);
            command = command.split("%MORTAR_PATCHES%").join(MORTAR_PATCHES);
            
            return command;
        }
        
         
		private function loadProjectList():void
		{
			log("Found projects:");
            
            //the current folder object
            var currentFolder:File = File.desktopDirectory.resolvePath( MORTAR_PROJECTS );
            
            //the current folder's file listing
            var files:Array = currentFolder.getDirectoryListing();
            
            //iterate and put files in the result and process the sub folders recursively
            for (var f:int = 0; f < files.length; f++) {
                if ( (files[f] as File).extension == "pro" )
                {
                    projectList.push((files[f] as File).name);
                    log("  " + (files[f] as File).name);
                }
            }
            
            for (var g:int = 0; g < files.length; g++) {
                if ( (files[g] as File).extension == "pro" )
                {
                    projectListCombo.selectedIndex = 0;
                    loadSettings(projectListCombo.selectedItem as String);
                    break;
                }
            }
        }
        
        private function syncPatchLists():void
        {
            for (var i:int = 0; i < patchBuildList.length; i++)
            {
                for (var x:int = 0; x < patchList.length; x++)
                {
                    if (patchBuildList[i] as String == patchList[x] as String)
                    {
                        patchList.splice(x, 1);
                    }
                    //patchList[i] = (patchList[i] as String).substr(MORTAR_PATCHES.length, (patchList[i] as String).length);
                }
            }
        }
        
        private function loadPatchList():void
        {
            patchList = new Array();
            
			log("Found patches:");
            
            getFilesRecursiveExt(MORTAR_PATCHES, "pat", patchList);
            
            for (var i:int = 0; i < patchList.length; i++)
            {
                patchList[i] = (patchList[i] as String).substr(MORTAR_PATCHES.length, (patchList[i] as String).length);
                log("  " + patchList[i]);
            }
        }
		
        private function loadSettings(project:String):void
		{
			log("Loading settings for project: " + project);
			
            loadPatchList();
            
            //Clear build array:
            patchBuildList = new Array();
            
			var settingsFileString:String = loadFileToString(MORTAR_PROJECTS + project);
			var settings:Array = settingsFileString.split("\n");
			
			for each( var setting:String in settings ) 
			{
				var settingBit:Array = setting.split("::|::");

				switch( settingBit[0] )
				{
					case "PROJ_PATH":
					{
						PROJ_PATH = (settingBit[1] as String).replace("\n", "").replace("\r", "");
						proj.text = PROJ_PATH;
						break;
					}
					case "BUNDLE_ID":
					{
						BUNDLE_ID = (settingBit[1] as String).replace("\n", "").replace("\r", "");
						buid.text = BUNDLE_ID;
						break;
					}
					case "PROJ_NAME":
					{
						PROJ_NAME = (settingBit[1] as String).replace("\n", "").replace("\r", "");
						projname.text = PROJ_NAME;
						break;
					}
                    
                    case "PATCH":
                    {
                        patchBuildList.push((settingBit[1] as String).replace("\n", "").replace("\r", ""));
                        break;
                    }
				}
			}
            
            syncPatchLists();
		}
		
		private function onTextInput():void
		{
			trace("PROJ_NAME:" + PROJ_NAME);
            log("PROJ_NAME:" + PROJ_NAME);
		}
		
        
        private function copyToClipboard():void
        {
           // log("tata");
           var total:String = "";
           for each(var s:String in consoleOutput )
           {
               total += s + "\n";
           }
           System.setClipboard(total); //consoleOutput.toString()
        }
        
        private function onDeleteProject(project:String):void
        {
            var index:int = -1;
            for ( var i:int = 0; i < projectList.length; i++ )
            {
                if (projectList[i] == project)
                {
                    index = i;
                }
            }
            
            if (index != -1)
            {
                log("Removing project: " + project);
                projectList.splice(index, 1);
                projectListCombo.selectedIndex = 0;
                loadSettings(projectListCombo.selectedItem as String);
               
                var file:File = File.applicationDirectory.resolvePath(MORTAR_PROJECTS + project);
                if (file.exists)
                {
                    file.deleteFile();
                }
            }
        }
        
        private function resetProjectSettings():void
        {
            PROJ_PATH = "Path to Eclipse project";
            BUNDLE_ID = "Your bundle id, such as com.modernalchemists.aaargpimples";
            PROJ_NAME = "The project name (STK name)";
            
        }
        
        public function addNewProject(name:String):void
        {
            log("Adding new project: " + name);
            projectList.push(name + ".pro");
            projectListCombo.selectedIndex = projectList.length - 1;
            
            resetProjectSettings();
            
            onSaveSettings();
            loadSettings(projectListCombo.selectedItem as String);
        }
        
        private function onNewProject():void
        {
            // Create a non-modal TitleWindow container.
            var popup:com.modernalchemists.AddProject = AddProject(PopUpManager.createPopUp(this, AddProject, true));         
            popup.inst = this;
            PopUpManager.centerPopUp(popup);
        }
        
        private function startPatching():void
        {
            for (var i:int = 0; i < patchBuildList.length; i++)
            {
                loadPatchFile(MORTAR_PATCHES + patchBuildList[i]);
            }
        }
        
		]]>		
	</mx:Script>

	<mx:VBox width="100%" horizontalAlign="center">
		
		<mx:HBox width="100%" backgroundColor="black">
			<mx:Image source="settings/header.png" />
		</mx:HBox>
		
        <!--<mx:HBox width="100%">
			<mx:Label width="100%" text="General Settings:" />
		</mx:HBox>-->
    
        <mx:VBox width="95%">
		<mx:Label text="Project Settings:" />
		<mx:VBox width="100%" borderStyle="solid" paddingTop="10" paddingBottom="10" paddingLeft="10" paddingRight="10">
            <mx:HBox width="100%">
                <mx:ComboBox  width="100%" height="100%" dataProvider="{projectList}" id="projectListCombo" change="loadSettings((projectListCombo.selectedItem)as String);"  />
                <mx:Button label="Delete Selected" click="onDeleteProject((projectListCombo.selectedItem) as String);" width="120" />
                <mx:Button label="Add Project" click="onNewProject();" width="120" />
            </mx:HBox>

			<mx:HBox width="100%">
				<mx:Label text="Path to Android/Eclipse-Project:" />
				<mx:TextInput id="proj" change="PROJ_PATH = proj.text" width="100%" text=""/>
				<mx:Button label="..." click="onBrowseProjectPath();" width="30" />
			</mx:HBox>
			
			<mx:HBox width="100%">
				<mx:Label text="Bundle Identifier:" />
				<mx:TextInput id="buid" change="BUNDLE_ID = buid.text" width="100%" text=""/>
			</mx:HBox>

			<mx:HBox width="100%">
				<mx:Label text="Project Name:" />
				<mx:TextInput id="projname" change="PROJ_NAME = projname.text;" width="100%" text=""/>
			</mx:HBox>
            
			<mx:HBox horizontalAlign="right" width="100%">
                <mx:Button label="Save Settings" click="onSaveSettings();" />
            </mx:HBox>
		</mx:VBox>
		
		<mx:Label styleName="containerVBox"  text="Patching:" />
		<mx:VBox width="100%" borderStyle="solid" paddingTop="10" paddingBottom="10" paddingLeft="10" paddingRight="10">
            <mx:HBox width="100%">
                <mx:VBox width="50%">
                    <mx:Label width="100%" text="Available Patches"/>
                    <mx:List width="100%" id="srclist" 
                        allowMultipleSelection="true"
                        dropEnabled="true"
                        dragEnabled="true"
                        dragMoveEnabled="true"
                        dataProvider="{patchList}" />
                </mx:VBox>

                <mx:VBox width="50%">
                    <mx:Label width="100%" text="Selected Patches"/>
                    <mx:List width="100%" id="destlist" 
                        allowMultipleSelection="true"
                        dropEnabled="true"
                        dragEnabled="true"
                        dragMoveEnabled="true"
                        dataProvider="{patchBuildList}" />
                </mx:VBox>
            </mx:HBox>
            
            <mx:HBox horizontalAlign="right" width="100%">
                <mx:Button label="Save Settings" click="onSaveSettings();" />
            </mx:HBox>
            
            <mx:HBox width="100%" horizontalAlign="center">
				<!--<mx:Button label="START PATCHING" click="prePatch(); patchAdMob(); postPatch();" width="100%" />-->
                <mx:Button label="START PATCHING" click="startPatching();" width="100%" />
			</mx:HBox>

        </mx:VBox>
		
		<mx:HBox width="100%">
            <mx:Label width="100%" text="Console Output:" />
            <mx:Button label="Copy Log to Clipboard" click="copyToClipboard();" />
        </mx:HBox>
		<mx:List  width="100%" height="100%" dataProvider="{consoleOutput}" verticalScrollPosition="{l.maxVerticalScrollPosition}" id="l" color="#000000" rowHeight="20" selectable="false" fontFamily="Courier">
        </mx:List>
		
	</mx:VBox>
	</mx:VBox>
</mx:WindowedApplication>